import asyncio
import json
import time
from typing import Dict

import websockets


class ModelPrompterClient:
    """
    Client for interacting with the model prompter server.
    """

    def __init__(self):
        self.uri = "ws://localhost:8765"

    async def prompt_model(self, prompt: str, model: str, max_new_tokens: int) -> str:
        """
        Sends a prompt to the server and returns the response.

        Args:
            prompt: The prompt to send to the server.
            model: The model to use for generating the response.
            max_new_tokens: The maximum number of tokens in the generated response.

        Returns:
            The response generated by the server.
        """
        while True:
            start_time = time.time()
            try:
                while True:
                    async with websockets.connect(self.uri, ping_timeout=600) as websocket:
                        request_payload = {
                            "prompt": prompt,
                            "model": model,
                            "max_new_tokens": max_new_tokens,
                        }
                        await asyncio.wait_for(websocket.send(json.dumps(request_payload)), timeout=240)
                        response = await asyncio.wait_for(websocket.recv(), timeout=240)
                        if len(response) == 0:
                            print("Response is empty... Retrying...")
                            continue
                        if response.startswith("ERROR"):
                            raise Exception(f"Error: {response}")
                        print("Took: " + str(time.time() - start_time))
                        return response
            except (websockets.exceptions.ConnectionClosedError, asyncio.TimeoutError) as e:
                print("Took: " + str(time.time() - start_time))
                print(f"Error: {e}")
                # Handle the error gracefully, e.g., retry or terminate the program

    async def list_available_models(self) -> Dict[str, str]:
        """
        Retrieves the available models from the server.

        Returns:
            A dictionary containing the available models.
        """
        try:
            async with websockets.connect(self.uri + "/list_directory/", ping_timeout=600) as websocket:
                await websocket.send("")
                response = await asyncio.wait_for(websocket.recv(), timeout=240)
                if response.startswith("Error"):
                    raise Exception(f"API Error: {response}")
                else:
                    return json.loads(response)
        except (websockets.exceptions.ConnectionClosedError, asyncio.TimeoutError) as e:
            print(f"Error: {e}")
            # Handle the error gracefully, e.g., retry or terminate the program


async def main():
    prompter = ModelPrompterClient()
    await prompter.prompt_model("Enter prompt", "model_name", 100)
    available_models = await prompter.list_available_models()
    print("Available Models:", available_models)


if __name__ == "__main__":
    asyncio.run(main())
